/**
 * Carousel initializer function 
 * 
 * Requires a contentElement : DOMElement in which the element generated by the 
 * elementGenerator from the stream of Objects, generated by the streamGenerator. 
 * 
 * leftButton, rightButton used to scroll the carousel left or right respectively. 
 * 
 * The carousel is reponsive in nature and will only add elements to the contentElement
 * if it can occupy hence overflowing is prevented. Although it is dependent on the 
 * element's width generated by the elementGenerator. 
 * 
 * @param {*} config 
 * @returns async function which on invoking will fill the 
 * contentElement. 
 */

let carousel = function (config) {
    let { contentElement, leftButton, rightButton, streamGenerator, elementGenerator } = config;

    rightButton = resetButton(rightButton); 
    leftButton = resetButton(leftButton);
    leftButton.classList.add("hidden");  

    rightButton.addEventListener("click", () => {
        scrollRight(contentElement);
    });

    leftButton.addEventListener("click", () => {
        scrollLeft(contentElement);
    });

    function scrollRight(carouselElm) {
        let visibleElements = carouselElm.querySelectorAll(".visible");
        let nextSibling = visibleElements[visibleElements.length - 1].nextElementSibling;
        let firstElem = nextSibling;
        if (!nextSibling)
            return;
        visibleElements.forEach(elm => {
            elm.classList.remove("visible");
            elm.classList.add("hidden");
        })
        let filledWidth = 0;
        let lstElm;
        while (nextSibling) {
            nextSibling.classList.remove("hidden");
            if (filledWidth + nextSibling.offsetWidth < carouselElm.clientWidth) {
                nextSibling.classList.add("visible");
                lstElm = nextSibling;
                filledWidth += nextSibling.offsetWidth;
            } else {
                nextSibling.classList.add("hidden");
            }

            nextSibling = nextSibling.nextElementSibling;
        }
        updateToggleBtnVisibility(firstElem, lstElm);
    }

    function scrollLeft(carouselElm) {
        let visibleElements = carouselElm.querySelectorAll(".visible");

        let prevSibling = visibleElements[0].
            previousElementSibling;
        let lstElm = prevSibling;
        if (!prevSibling)
            return;
        visibleElements.forEach(elm => {
            elm.classList.remove("visible");
            elm.classList.add("hidden");
        })
        let filledWidth = 0;
        let firstElem;
        while (prevSibling) {
            prevSibling.classList.remove("hidden");
            if (filledWidth + prevSibling.offsetWidth < carouselElm.clientWidth) {
                prevSibling.classList.add("visible");
                firstElem = prevSibling;
                filledWidth += prevSibling.offsetWidth;
            } else {
                prevSibling.classList.add("hidden");
            }
            prevSibling = prevSibling.previousElementSibling;
        }
        updateToggleBtnVisibility(firstElem, lstElm);
    }

    function updateToggleBtnVisibility(firstElem, lstElm) {
        if (firstElem.previousElementSibling)
            leftButton.classList.remove("hidden");
        else
            leftButton.classList.add("hidden");
        if (lstElm.nextElementSibling)
            rightButton.classList.remove("hidden");
        else
            rightButton.classList.add("hidden");
    }

    function emptyContent() {
        while (contentElement.lastElementChild)
            contentElement.lastElementChild.remove();
    }

    //wil remove all the classes 
    //and events which are used in the previous 
    //carousel mode
    function resetButton(btn){ 
        btn.classList.remove(...btn.classList); 
        btn.classList.add("center"); 
        let oldBtn = btn; 
        let newBtn = oldBtn.cloneNode(true);
        oldBtn.parentNode.replaceChild(newBtn, oldBtn);  
        return newBtn; 
    }

    async function fillContent() {
        emptyContent();
        let promises = []; 
        let filledWidth = 0;
       
        async function __genInit(element){ 
            let elementGenerated = elementGenerator(element);
            contentElement.append(elementGenerated);
            if (filledWidth + elementGenerated.offsetWidth < contentElement.clientWidth) {
                elementGenerated.classList.add("visible");
                filledWidth += elementGenerated.offsetWidth;
            } else {
                elementGenerated.classList.add("hidden");
            }
        }

        if (streamGenerator()) {
            streamGenerator().forEach(element => {
              promises.push(__genInit(element)); 
            });
        };

        Promise.all(promises); 
    }
    return fillContent;
};

export default carousel;
